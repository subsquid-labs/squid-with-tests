// main.ts
// This is the main executable of the squid indexer.

// The processor object (responsible for data retrieval)
// is defined in processor.ts, alongside some other constants.
import {
  processor,
  CONTRACT_ADDRESS,
  type Log
} from './processor'
// TypeormDatabase is the class responsible for data storage.
import {TypeormDatabase} from '@subsquid/typeorm-store'
// erc20abi is a utility module generated from the common JSON ABI
// of ERC20 contracts. It contains methods for event decoding,
// direct RPC queries and some useful constants.
import * as erc20abi from './abi/erc20'
// Transfer and Account are TypeORM model classes
// of the `transfer` and `account` Postgres tables, respectively.
// They are autogenerated from schema.graphql.
import {Transfer, Account} from './model'

import {RawTransfer, handleTransfers} from './batchHandlers/transfer'

// TypeormDatabase objects store the data to Postgres. They are capable of
// handling the rollbacks that occur due to blockchain forks.
//
// There are also Database classes for storing data to files and BigQuery
// datasets.
const db = new TypeormDatabase({supportHotBlocks: true})

// the handler function that is executed once on each batch of data. Processor
// object provides the data via "ctx.blocks". However, the handler can contain
// arbitrary TypeScript code, so it's OK to bring in extra data from IPFS,
// direct RPC calls, external APIs etc.
processor.run(db, async (ctx) => {
  // Making the container to hold the raw decoded data on token transfers.
  const rawTransfers: RawTransfer[] = []

  // The data retrieved from the SQD Network gateway and/or the RPC endpoint
  // is supplied via ctx.blocks
  for (let block of ctx.blocks) {
    // On EVM, each block has four iterables - logs, transactions, traces,
    // stateDiffs
    // We'll go through the logs, sort and decode them, then pass them to
    // handler functions.
    for (let log of block.logs) {
      if (log.address === CONTRACT_ADDRESS &&
          log.topics[0] === erc20abi.events.Transfer.topic) {
        // SQD's very own EVM codec at work - about 20 times faster than ethers
        let {from, to, value} = erc20abi.events.Transfer.decode(log)
        rawTransfers.push({
          id: log.id,
          block: block.header.height,
          from,
          to,
          value,
          txnHash: log.transactionHash
        })
      }
    }
  }

  // Database IO is typically the most expensive operation
  // when writing to Postgres. The main idea behind the rest of
  // the processing code is to optimize for it.

  // The handler operates on an array, not on individual events,
  // so any read operations that the handlers may need
  // can be batched. We avoid write operations in handlers to allow
  // any subsequent handlers to use and possibly enrich the data.
  const {transfers, accounts} = await handleTransfers(ctx, rawTransfers)

  // All write operations are batched
  await ctx.store.insert(transfers)
  await ctx.store.upsert(accounts)
})
